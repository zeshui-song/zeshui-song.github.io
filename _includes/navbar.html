<style>
    /* 1. Define a consistent breakpoint for the "Mobile UI" */
    @media (max-width: 768px) {
        #mainNav {
            height: 20px !important; 
            padding: 0 !important;
            margin-bottom: 40px !important;
        }
        #canvasParent { display: none !important; }
        .desktop-nav { display: none !important; }
        .menu-toggle {
            display: block !important;
            margin-top: 40px !important; 
            background: none;
            border: none;
            cursor: pointer;
            z-index: 11;
            position: relative;
        }
    }

    /* Desktop defaults */
    .menu-toggle { display: none; outline: none; color: var(--text-color, #000); }
    .mobile-nav { display: none; }
    .nav-open .mobile-nav {
        display: flex; flex-direction: column; position: absolute;
        top: 60px; right: 0; background: #fff; width: 100%;
        box-shadow: 0 4px 6px rgba(0,0,0,0.1); z-index: 10;
    }
    .mobile-nav a { padding: 15px; text-align: center; border-bottom: 1px solid #eee; text-decoration: none; color: #333; }
</style>

<nav id="mainNav" style="display: flex; align-items: center; justify-content: space-between; padding: 10px 0; height: 80px; position: relative;">
    <div id="canvasParent" style="flex: 1; height: 100%; display: flex; align-items: center; overflow: hidden; margin-right: 20px;">
        <canvas id="cycloidCanvas" style="width: 100%; height: 60px; display: block;"></canvas>
    </div>

    <div class="right desktop-nav">
        <a href="/"><span>Home</span></a>
        <a href="/projects/"><span>Projects</span></a>
        <a href="/research/"><span>Research</span></a>
        <a href="/about/"><span>About</span></a>
        <a href="{{site.resume-url}}" target="_blank" rel="noopener noreferrer">
            <span>Resume</span>
        </a>
    </div>

    <button class="menu-toggle" id="menuToggle" aria-label="Toggle menu">
        <i class="fa fa-bars fa-2x"></i>
    </button>

    <div class="mobile-nav">
        <a href="/"><span>Home</span></a>
        <a href="/projects/"><span>Projects</span></a>
        <a href="/research/"><span>Research</span></a>
        <a href="/about/"><span>About</span></a>
        <a href="{{site.resume-url}}" target="_blank" rel="noopener noreferrer">
            <span>Resume</span>
        </a>
    </div>
</nav>

<script>
    const canvas = document.getElementById('cycloidCanvas');
    const ctx = canvas.getContext('2d');
    const parent = document.getElementById('canvasParent');
    const mainNav = document.getElementById('mainNav');
    const menuToggle = document.getElementById('menuToggle');

    const isAboutPage = window.location.pathname.includes('/about/');
    const isResearchPage = window.location.pathname.includes('/research/');

    let angle = 0;
    let xOffset = 0; 
    let direction = 1; 
    let isErasing = false;
    
    // Research Page Variables
    let waveTime = 0;
    let wavefrontX = 0; 
    let reflectedFrontX = 0;
    let wavePhase = 'propagating'; // 'propagating', 'reflecting', 'steady'

    const radius = 14;      
    const armLength = 22;   
    const speed = 0.05;
    const agnesiSpeed = 0.8; 
    let points = [];
    
    let isRolling = true;
    let dpr, w, h, centerY;

    menuToggle.addEventListener('click', () => {
        mainNav.classList.toggle('nav-open');
    });

    function resize() {
        if (!parent) return;
        dpr = window.devicePixelRatio || 1;
        w = parent.offsetWidth;
        h = 60; 
        canvas.width = w * dpr;
        canvas.height = h * dpr;
        ctx.scale(dpr, dpr);
        centerY = h / 2; 
        points = [];
        angle = 0;
        
        const limit = w * 0.45;
        xOffset = -limit; 
        direction = 1;
        isErasing = false;
        isRolling = true;

        // Reset Research Animation
        const margin = 40;
        wavefrontX = margin;
        reflectedFrontX = w - margin;
        wavePhase = 'propagating';
    }

    window.addEventListener('resize', resize);
    resize();

    function draw() {
        if (mainNav.classList.contains('nav-open') || getComputedStyle(document.getElementById('canvasParent')).display === 'none') {
            requestAnimationFrame(draw);
            return;
        }

        ctx.clearRect(0, 0, w, h);

        let px, py, centerX;
        const limit = w * 0.45;

        if (isResearchPage) {
            waveTime += 0.05;
            const margin = 40;
            const rightBound = w - margin;
            const propSpeed = 2.5;

            // Amplitude logic: 
            // Pipe half-height is 25. Standing wave peak (2A) should be ~24.
            // Therefore, traveling wave amplitude (A) is 12.
            const pipeHalfHeight = 25;
            const amp = 12; 

            const L = rightBound - margin;
            const freq = (2 * Math.PI) / (L / 2); // n=2 mode

            if (wavePhase === 'propagating') {
                wavefrontX += propSpeed;
                if (wavefrontX >= rightBound) {
                    wavefrontX = rightBound;
                    wavePhase = 'reflecting';
                }
            } else if (wavePhase === 'reflecting') {
                reflectedFrontX -= propSpeed;
                if (reflectedFrontX <= margin) {
                    reflectedFrontX = margin;
                    wavePhase = 'steady';
                }
            }

            // Draw Open Pipe (Black and Bold)
            ctx.beginPath();
            ctx.strokeStyle = '#000';
            ctx.lineWidth = 2.5;
            ctx.moveTo(margin, centerY - pipeHalfHeight);
            ctx.lineTo(rightBound, centerY - pipeHalfHeight);
            ctx.moveTo(margin, centerY + pipeHalfHeight);
            ctx.lineTo(rightBound, centerY + pipeHalfHeight);
            ctx.stroke();

            // 1. Traveling Wave (Solid Grey)
            ctx.beginPath();
            ctx.setLineDash([]);
            ctx.strokeStyle = '#ddd';
            ctx.lineWidth = 1.2;
            for (let x = margin; x <= wavefrontX; x++) {
                const y = centerY + amp * Math.cos(freq * (x - margin) - waveTime);
                if (x === margin) ctx.moveTo(x, y);
                else ctx.lineTo(x, y);
            }
            ctx.stroke();

            // 2. Reflected Wave (Dotted Grey)
            if (wavePhase !== 'propagating') {
                ctx.beginPath();
                ctx.setLineDash([4, 4]);
                ctx.strokeStyle = '#ccc';
                for (let x = rightBound; x >= reflectedFrontX; x--) {
                    const y = centerY + amp * Math.cos(freq * (x - margin) + waveTime);
                    if (x === rightBound) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
                ctx.setLineDash([]);
            }

            // 3. Standing Wave (Blue Interference)
            if (wavePhase !== 'propagating') {
                ctx.beginPath();
                ctx.strokeStyle = 'rgba(0, 123, 255, 0.7)';
                ctx.lineWidth = 2.5;
                for (let x = reflectedFrontX; x <= rightBound; x++) {
                    const y1 = amp * Math.cos(freq * (x - margin) - waveTime);
                    const y2 = amp * Math.cos(freq * (x - margin) + waveTime);
                    const y = centerY + (y1 + y2);
                    if (x === Math.ceil(reflectedFrontX)) ctx.moveTo(x, y);
                    else ctx.lineTo(x, y);
                }
                ctx.stroke();
            }

        } else if (isAboutPage) {
            const a = radius;
            centerX = w / 2;
            const groundY = h - 10; 
            const topY = groundY - 2 * a; 

            px = centerX + xOffset;
            const yFromBottom = (8 * Math.pow(a, 3)) / (Math.pow(xOffset, 2) + 4 * Math.pow(a, 2));
            py = groundY - yFromBottom;

            if (!isErasing) {
                points.push({x: px, y: py});
                xOffset += (agnesiSpeed * direction);

                if (xOffset > limit || xOffset < -limit) {
                    isErasing = true;
                }
            } else {
                if (points.length > 0) {
                    points.splice(0, 4); 
                } else {
                    direction *= -1;
                    isErasing = false;
                }
            }
        } else {
            centerX = (radius * angle) - radius;
            px = centerX - armLength * Math.sin(angle);
            py = centerY + armLength * Math.cos(angle);

            if (isRolling) {
                points.push({x: px, y: py});
                angle += speed;
                if (centerX > w + armLength + radius) isRolling = false;
            } else {
                if (points.length > 0) points.splice(0, 3);
                else { isRolling = true; angle = 0; }
            }
        }

        // Shared Traced Path Logic
        if (!isResearchPage && points.length > 1) {
            ctx.beginPath();
            ctx.strokeStyle = 'rgba(0, 123, 255, 0.4)';
            ctx.lineWidth = 2.5;
            ctx.lineCap = 'round';
            ctx.moveTo(points[0].x, points[0].y);
            for (let i = 1; i < points.length; i++) {
                ctx.lineTo(points[i].x, points[i].y);
            }
            ctx.stroke();
        }

        if (!isResearchPage && (isAboutPage || isRolling)) {
            ctx.lineWidth = 1.2;
            if (isAboutPage) {
                const a = radius;
                const groundY = h - 10; 
                const circleX = w / 2;
                const circleY = groundY - a;
                const topY = groundY - 2 * a;

                ctx.beginPath();
                ctx.moveTo(centerX - limit, topY); 
                ctx.lineTo(centerX + limit, topY);
                ctx.strokeStyle = '#eee';
                ctx.stroke();

                ctx.beginPath();
                ctx.arc(circleX, circleY, a, 0, Math.PI * 2);
                ctx.strokeStyle = '#444';
                ctx.stroke();

                const yFromBottom = groundY - py;
                const intersectionX = circleX + (yFromBottom * (xOffset / (2 * a)));

                ctx.setLineDash([2, 2]);
                ctx.strokeStyle = '#bbb';
                ctx.beginPath();
                ctx.moveTo(circleX, groundY);
                ctx.lineTo(px, topY);
                ctx.stroke();

                ctx.strokeStyle = '#28a745';
                ctx.beginPath();
                ctx.moveTo(px, py); ctx.lineTo(px, topY); 
                ctx.moveTo(px, py); ctx.lineTo(intersectionX, py); 
                ctx.stroke();
                ctx.setLineDash([]);

                ctx.beginPath();
                ctx.arc(intersectionX, py, 3, 0, Math.PI * 2);
                ctx.fillStyle = '#888';
                ctx.fill();

            } else {
                ctx.beginPath();
                ctx.arc(centerX, centerY, radius, 0, Math.PI * 2);
                ctx.strokeStyle = '#444'; ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(centerX, centerY); ctx.lineTo(px, py);
                ctx.strokeStyle = '#bbb'; ctx.stroke();
            }

            ctx.beginPath();
            ctx.arc(px, py, 4, 0, Math.PI * 2);
            ctx.fillStyle = '#007bff';
            ctx.fill();
        }

        requestAnimationFrame(draw);
    }
    draw();
</script>